/**
 * API Module - Loads commit metadata from static JSON, fetches diffs on-demand
 * Metadata is pre-generated by scripts/generate_data.py
 * Diffs are fetched from git.tricoteuses.fr when needed
 */

const API = (() => {
    const DATA_PATH = 'data';
    const FORGEJO_BASE = 'https://git.tricoteuses.fr/codes';
    const cache = new Map();

    // Metadata patterns to filter from diffs (match Python's patterns)
    const METADATA_PATTERNS = [
        /^Nature:\s*/i,
        /^Numéro:\s*/i,
        /^Type:\s*/i,
        /^État:\s*/i,
        /^Date de début:\s*/i,
        /^Date de fin:\s*/i,
        /^Identifiant:\s*/i,
        /^Ancien identifiant:\s*/i,
        /^URL:\s*/i,
        /^Origine:\s*/i,
        /^NOTA:\s*$/i,
        /^Liens relatifs à cet article\s*$/i,
        /^Cite:\s*$/i,
        /^Cité par:\s*$/i,
        /^Anciens textes:\s*$/i,
        /^Nouveaux textes:\s*$/i,
        /^LEGI[A-Z]{4}\d{12}$/
    ];

    function isMetadataLine(content) {
        const stripped = content.trim();
        if (!stripped) return false;
        return METADATA_PATTERNS.some(pattern => pattern.test(stripped));
    }

    function htmlToText(content) {
        if (!content || !content.includes('<')) return content;

        let text = content;
        // Convert <br> and <br/> to newlines
        text = text.replace(/<br\s*\/?>/gi, '\n');
        // Convert </p> to double newline
        text = text.replace(/<\/p\s*>/gi, '\n\n');
        // Remove <p> opening tags
        text = text.replace(/<p\s*[^>]*>/gi, '');
        // Extract link text from <a> tags
        text = text.replace(/<a\s+[^>]*>([^<]*)<\/a>/gi, '$1');
        // Remove all other HTML tags
        text = text.replace(/<[^>]+>/g, '');
        // Decode HTML entities
        const textarea = document.createElement('textarea');
        textarea.innerHTML = text;
        text = textarea.value;
        // Clean up excessive whitespace
        text = text.replace(/\n{3,}/g, '\n\n').trim();

        return text;
    }

    function formatArticleName(filename) {
        const parts = filename.split('/');
        const name = parts[parts.length - 1].replace(/\.md$/, '');

        if (name.startsWith('article_')) {
            const articleId = name.substring(8).toUpperCase().replace(/_/g, ' ');
            return `Article ${articleId}`;
        }

        if (name.toLowerCase() === 'readme') {
            if (parts.length > 1) {
                const parent = parts[parts.length - 2].replace(/_/g, ' ');
                return `Sommaire - ${parent.charAt(0).toUpperCase() + parent.slice(1)}`;
            }
            return 'Sommaire';
        }

        return name.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
    }

    function parseUnifiedDiff(diffText) {
        const files = [];
        let currentFile = null;
        let currentDiff = [];
        let additions = 0;
        let deletions = 0;
        let status = 'modified';

        for (const line of diffText.split('\n')) {
            if (line.startsWith('diff --git')) {
                // Save previous file
                if (currentFile) {
                    files.push({
                        filename: currentFile,
                        articleName: formatArticleName(currentFile),
                        additions,
                        deletions,
                        diff: currentDiff,
                        status
                    });
                }

                // Extract filename from "diff --git a/path b/path"
                const match = line.match(/diff --git a\/.+ b\/(.+)/);
                currentFile = match ? match[1] : null;
                currentDiff = [];
                additions = 0;
                deletions = 0;
                status = 'modified';
            } else if (line.startsWith('new file mode')) {
                status = 'added';
            } else if (line.startsWith('deleted file mode')) {
                status = 'deleted';
            } else if (currentFile && line.startsWith('+') && !line.startsWith('+++')) {
                const content = line.substring(1);
                if (!isMetadataLine(content)) {
                    additions++;
                    currentDiff.push({ type: 'add', content: htmlToText(content) });
                }
            } else if (currentFile && line.startsWith('-') && !line.startsWith('---')) {
                const content = line.substring(1);
                if (!isMetadataLine(content)) {
                    deletions++;
                    currentDiff.push({ type: 'del', content: htmlToText(content) });
                }
            } else if (currentFile && !line.startsWith('@@') && !line.startsWith('\\') && !line.startsWith('index ') && !line.startsWith('---') && !line.startsWith('+++')) {
                const content = line.startsWith(' ') ? line.substring(1) : line;
                if (!isMetadataLine(content)) {
                    currentDiff.push({ type: 'unchanged', content: htmlToText(content) });
                }
            }
        }

        // Save last file
        if (currentFile) {
            files.push({
                filename: currentFile,
                articleName: formatArticleName(currentFile),
                additions,
                deletions,
                diff: currentDiff,
                status
            });
        }

        return files;
    }

    async function loadJson(path) {
        const cached = cache.get(path);
        if (cached) return cached;

        const response = await fetch(`${DATA_PATH}/${path}`);
        if (!response.ok) {
            throw new Error(`Failed to load ${path}: ${response.status}`);
        }
        const data = await response.json();
        cache.set(path, data);
        return data;
    }

    async function fetchRepositories() {
        return loadJson('repos.json');
    }

    async function fetchCommits(repoName, since, until) {
        const commits = await loadJson(`commits/${repoName}.json`);

        // Filter by date range
        return commits.filter(c => {
            if (since && c.date < since) return false;
            if (until && c.date > until) return false;
            return true;
        });
    }

    async function fetchCommitDetail(repoName, sha) {
        // Check cache first
        const cacheKey = `detail:${repoName}:${sha}`;
        const cached = cache.get(cacheKey);
        if (cached) return cached;

        // Get full SHA from commits data
        const commits = await loadJson(`commits/${repoName}.json`);
        const commit = commits.find(c => c.sha === sha.substring(0, 12) || c.fullSha === sha);

        if (!commit) {
            throw new Error(`Commit ${sha} not found in ${repoName}`);
        }

        const fullSha = commit.fullSha || sha;

        // Fetch raw diff from Forgejo
        const diffUrl = `${FORGEJO_BASE}/${repoName}/commit/${fullSha}.diff`;
        const response = await fetch(diffUrl);

        if (!response.ok) {
            throw new Error(`Failed to fetch diff: ${response.status}`);
        }

        const diffText = await response.text();
        const files = parseUnifiedDiff(diffText);

        // Calculate stats
        const totalAdditions = files.reduce((sum, f) => sum + f.additions, 0);
        const totalDeletions = files.reduce((sum, f) => sum + f.deletions, 0);

        const detail = {
            sha: commit.sha,
            date: commit.date,
            message: commit.message,
            files,
            stats: {
                additions: totalAdditions,
                deletions: totalDeletions,
                filesChanged: files.length
            }
        };

        cache.set(cacheKey, detail);
        return detail;
    }

    function formatCodeName(name) {
        const display = name.replace(/_/g, ' ');
        return display.charAt(0).toUpperCase() + display.slice(1);
    }

    return {
        fetchRepositories,
        fetchCommits,
        fetchCommitDetail,
        formatCodeName
    };
})();
